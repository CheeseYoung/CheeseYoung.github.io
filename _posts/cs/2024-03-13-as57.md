---
layout: post
title: <운영체제> 8. 인터럽트(Interrupt)
subtitle: Engineer Information Processing
author: Jo
categories: CS
banner:
  image: https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/19b32eaf-d2f5-4d13-82ea-4f45e1a37545
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"
  subheading_style: "color: gold"
tags: Study

---

# 목차
📌 인터럽트(Interrupt) <br>
🕳 시스템 콜(System Call) <br>
🕳 교착 상태(Deadlock) <br>
<br>
<hr>

# 인터럽트
주변 장치와 입출력 장치는 CPU나 메모리와 달리 ``인터럽트``라는 매커니즘을 통해 관리된다.
> 이유는 입출력 연산이 CPU 명령 수행속도보다 현저히 느리기 때문이다.
- CPU가 입출력연산의 속도(매우 느림)에 맞추면 능력에 비해 쉬는 텀이 길어진다.
- 그래서 입출력연산 결과가 나올 때 까지 CPU는 다른 일을 하고,
  입출력 연산이 완료되면 CPU에게 알려주는 것이 **인터럽트**다.

## 인터럽트란?
- CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여
  처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말한다.
  인터럽트는 크게 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉜다.
<br>
- 하드웨어 인터럽트
  - 하드웨어가 발생시키는 인터럽트
  - CPU가 아닌 다른 하드웨어 장치가 cpu에 어떤 사실을 알려주거나 cpu 서비스를 요청해야 할 경우 발생
- 소프트웨어 인터럽트
  - 소프트웨어가 발생시키는 인터럽트
  - 소프트웨어(사용자 프로그램)가 스스로 인터럽트 라인을 세팅한다.
  - 종류: 예외 상황, system call
<br>
- 인터럽트를 발생시키기 위해 하드웨어/소프트웨어는 CPU내에 있는 ``인터럽트 라인``을 세팅하여 인터럽트를 발생시킨다.
- CPU는 매번 명령을 수행하기 전에 인터럽트라인이 세팅되어있는지를 검사한다.

## 인터럽트 과정
process A 실행 중 디스크에서 어떤 데이터를 읽어오라는 명령을 받았다고 가정해보자.
<br>
- process A는 ``system call``을 통해 인터럽트를 발생시킨다.
- CPU는 현재 진행 중인 기계어 코드를 완료한다.
- 현재까지 수행중이었던 상태를 해당 process의 ``PCB(Process Control Block)``에 저장한다.
  (수행중이던 메모리주소, 레지스터 값, 하드웨어 상태 등)
- PC(Program Counter, IP)에 다음에 실행할 명령의 주소를 저장한다.
- 인터럽트 벡터를 읽고 ISR 주소값을 얻어 ISR(Interrupt Service Routine)로 점프하여 루틴을 실행한다.
- 해당 코드를 실행한다.
- 해당 일을 다 처리하면, 대피시킨 레지스터를 복원한다.
- ISR의 끝에 IRET 명령어에 의해 인터럽트가 해제 된다.
- IRET 명령어가 실행되면, 대피시킨 PC 값을 복원하여 이전 실행 위치로 복원한다.

## 인터럽트와 특권 명령
# 명령어의 종류
CPU가 수행하는 명령에는 ``일반 명령``과 ``특권 명령``이 있다.
- 일반 명령
  - 메모리에서 자료를 읽어오고, CPU에서 계산을 하는 등의 명령
  - 모든 프로그램이 수행할 수 있다.
- 특권 명령
  - 보안이 필요한 명령으로 입출력 장치, 타이머 등의 장치를 접근하는 명령
  - 특권 명령은 항상 운영체제만이 수행할 수 있다.
<br>
# kernel mode vs user mode
운영체제는 하드웨어적인 보안을 유지하기 위해 기본적으로 두가지 operation을 지원한다.
- kernel mode
  - 운영체제가 CPU의 제어권을 가지고 명령을 수행하는 모드
  - 일반 명령과 특권 명령 모두 수행할 수 있다.
- user mode
  - 일반 사용자 프로그램이 CPU 제어권을 가지고 명령을 수행하는 모드
  - 일반 명령만을 수행할 수 있다.
<br>
# 과정
위의 process A가 프로그램 명령 수행중에 디스크 입출력 명령을 읽은 경우를 생각해 보자. 
- 사용자 프로그램은 입출력 장치에 접근하는 명령을 수행할 수 없다. 
  - user mode에서 특권 명령을 수행할 수 없기 때문이다.
- 이런 경우에 사용자 프로그램은 운영체제에게 ``시스템 콜``을 통해 특권명령을 대신 수행해달라고 요청한다.
- 시스템 콜은 주소 공간 자체가 다른 곳(커널의 code영역)으로 이동해야 하므로
  - 프로그램이 인터럽트 라인에 인터럽트를 세팅하는 명령을 통해 이루어진다.
> 시스템 콜은 커널 영역의 기능을 사용자 모드가 사용 가능하게,
> 즉 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게 해준다.
- CPU가 인터럽트 라인을 검사하고 인터럽트가 발생한 것을 감지하게 된다.
- 현재 수행중인 사용자 프로그램을 잠시 멈추고 CPU의 제어권을 운영체제에게 양도한다.(kernel mode)
- 그리고 이 때 하드웨어적으로 모드 비트가 1에서 0으로 자동으로 세팅되어 특권 명령을 수행할 수 있게 된다.
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/19b32eaf-d2f5-4d13-82ea-4f45e1a37545)


## 관련 용어
# 인터럽트 핸들러
- 실제 인터럽트를 처리하기 위한 루틴으로 인터럽트 서비스 루틴이라고도 한다.
- 운영체제의 코드 영역에는 인터럽트별로 처리해야할 내용이 이미 프로그램되어 있다.

# 인터럽트 벡터
- 인터럽드 발생시 처리해야 할 인터럽트 핸들러의 주소를 인터럽트 별로 보관하고 있는 테이블이다.

# PCB(Process Control Block)
- 커널의 데이터 영역에 존재하며 각각의 프로세스마다 고유의 PCB가 있다.
- 인터럽트 발생 시 프로세스의 어느 부분이 수행중이었는지를 저장한다.
  - (수행중이던 memory 주소, 레지스터값, 하드웨어 상태 ...)














