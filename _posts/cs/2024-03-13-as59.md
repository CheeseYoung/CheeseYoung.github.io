---
layout: post
title: "[운영체제] 10. 교착 상태(Deadlock)"
subtitle: Engineer Information Processing
author: Jo
categories: CS
banner:
  image: https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/5301ed3d-6f59-482b-bd76-748f837946d4
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 3em; font-weight: bold;"
  subheading_style: "color: gold"
tags: Study

---

# 목차
🕳 인터럽트(Interrupt) <br>
🕳 시스템 콜(System Call) <br>
📌 교착 상태(Deadlock) <br>
<br>
<hr>


## 교착 상태(Deadlock)란?
- 교착상태는 프로세스가 발생가능성이 없는 이벤트를 기다리고 있는 경우 프로세스가 교착 상태에 있다고 하며
- 시스템 내에 교착 상태인 프로세스가 있는 경우 시스템이 교착 상태에 있다고 말한다.
- 무한정 대기 상태에서 빠져나올 수 없는 상태에 있는 것인데 이는 기아(Starvation) 현상과 구분해야할 필요가 있다. 
  - # Starvation 현상
    - starvation현상은 프로세스가 Ready 상태에 있을 때 발생한다.
    - 프로세서를 제외한 모든 자원은 할당되어있는 상태이나 프로세서를 할당받지 못해 Ready 상태에 장기적으로 머무르는 것
  - # 교착상태(Deadlock)
    - 교착 상태는 프로세스가 추가적인 자원 할당을 요청하는 Asleep(Block)상태에서 발생한다.
    - 자원할당을 요청했으나 할당받지 못하는 상태에 있어 Ready 상태로 갈 수 없는 상태이다.

## 교착 상태 표현법
# Graph Model
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/5301ed3d-6f59-482b-bd76-748f837946d4)
- 위는 그래프 형태로 교착 상태를 표현한 것이다.
- 그래프의 노드는 프로세스 노드, 자원 노드로 나뉘어이다.
- 자원 노드가 프로세스 노드를 가리키는 엣지는 해당 자원이 해당 프로세스에 할당이 되어있음
- 프로세스 노드가 자원 노드를 가리키는 엣지는 해당 프로세스가 해당 자원 할당을 요청함
- 현재 위 그래프를 보면 여유 자원이 없는 상태에서 서로 자원을 요청만 할 뿐 어느 한쪽도 먼저 정상 종료될 수 없는 상태로 교착 상태임을 알 수 있다.
<br>
# State Transition Model
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/816fc520-58e1-4fd9-ba77-c486bc7abe4c)
- 위 표현은 2개의 프로세스와 같은 종류의 자원이 2개 존재하고
- 프로세스는 한번에 자원 하나만 요청/반납 가능하다고 가정하였을 때 모든 상황을 살펴보는 모델이다.
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/38516b12-0f1f-4a85-9f29-37dcbda2e2ac)
- 위 표는 한 프로세스가 가질 수 있는 상황이다.
- 총 5개의 상황으로 N개의 자원을 가지고 자원 할당을 요청하는지 안하는지에 대한 상황이다.
- 총 2개의 프로세스이므로 일어날 수 있는 상황은 25개이다.
- 그 중 2개 이상 자원이 할당받은 경우는 없으므로 20개의 상황이 있다.
- 각 상황의 이름은 ``S``,``X``,``Y`` 형태로 X는 P1의 상황번호, Y는 P2의 상황 번호이다.
- 만약 S33의 경우 P1이 1개의 자원을 할당받고 1개의 자원을 요청하고 있으며, 동시에 P2가 1개의 자원을 할당받고 1개의 자원을 요청받는 교착상태인 것이다.
- 그리고 각 State가 이어진 간선에 1 또는 2라고 표시되어 있는 것은 프로세스의 번호이며,
  요청(Request), 할당(Allocate), 반납(Return)을 표시하고 있다.
- ![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/ff49948b-f667-4077-8b0e-7284cfb8b15a)
- 위처럼 정방향 간선의 홀수번째는 요청, 정방향 간선의 짝수번째는 할당, 역방향 간선은 반납을 의미

## 교착상태 발생 필요조건
- Exclusive use of resources : 한 번에 한 프로세스만
- Non-preemptible resources : 비선점 자원
- Hold and wait(Partial allocation) : 부분 할당으로 자원을 하나 잡고 다른 자원을 요청
- Circular Wait : 프로세스1이 프로세스2가 점유하고 있는 자원을 요청하고
  프로세스2가 프로세스1이 점유하고 있는 자원을 요청하여 순환요청으로 인해 무한정대기상태가 되는 것
> 이러한 교착 상태는 해결방법이 3가지가 존재하는데 교착상태 ``예방``, ``회피``, ``탐지 및 복구``가 있다.

## 교착 상태 해결 방법
# 교착 상태 에방
- 교착 상태 해결방법 중 교착 상태 예방 방법은 교착 상태 발생 필요조건 중 하나를 제거해버리는 방법이다.
- 4개의 조건이 모두 만족되어야 교착 상태가 발생하므로 그 중 하나를 제거하여 교착상태를 발생시키지 않도록 하는 방법이다.
<br>
- Exclusive use of resources
  - 이 조건을 제거하는 것은 모든 자원을 공유 허용을 한다는 뜻이다.
  - 하지만 이는 현실적으로 불가능하다.
- Non-preeMptible resources
  - 이 조건을 제거하는 것은 모든 자원에 대해 선점을 허용하는 것이다.
  - 이또한 현실적으로 불가능하다.
  - 유사한 방법으로 프로세스가 할당받을 수 없는 자원을 요청한 경우, 기존에 가지고 있던 자원을 모두 반납하고 작업을 취소한 뒤 체크포인트부터 다시 시작하는 방법이 있다.
  - 하지만 이 방법은 작업을 취소하고 다시 시작하는 것 자체가 심각한 자원 낭비를 발생시키고 사용할 수 없는 방법이다.
- Hold and wait
  - 이 조건을 제거하는 것은 한 프로세스가 필요한 자원을 한 번에 모두 할당하는 것을 말한다.
  - 이는 자원이 필요하지 않은 순간에도 시작할 때부터 미래에 필요하기 때문에 계속 가지고 있게 되는데 자원 낭비가 발생한다.
  - 또한 다른 프로세스가 먼저 작업을 시작한 프로세스가 끝날 때까지 대기하여야 한다.
- Circular wait
  - 이 조건을 제거하는 것은 자원 일괄 할당을 일반화한 방법이다.
  - 자원들에게 순서를 부여하고 프로세스는 순서의 증가 방향으로만 자원을 요청가능하도록 하는 방법이다.
  - 이 또한 자원 낭비가 발생한다.
> 결국 교착상태를 예방하는 행위는 절대 교착상태가 발생하지 않으나 심각한 자원 낭비가 발생하고 이는 비현실적이다.
<br>
# 교착상태 회피
- 교착상태 회피는 시스템의 상태를 항상 감시하며 교착 상태가 될 가능성이 있는 자원 할당 요청을 보류하며 항상 Safe State를 유지하는 것을 말한다.
- Safe State는 모든 프로세스가 정상적으로 종료되는 순서(Safe Sequence)가 존재하는 상태를 말하며 교착상태가 되지 않을 수 있음을 보장한다.
- Unsafe State는 교착상태 발생 가능성이 있는 상태이나 반드시 발생을 한다는 뜻은 아니다.
<br>
교착 상태 회피를 위해서는 4가지의 가정이 필요하다.
- 프로세스의 수 고정
- 자원의 종류와 수 고정
- 프로세스가 요구하는 자언 및 최대 수량을 알고있음
- 프로세스는 자원을 사용 후 반드시 반납함  
<br>
# 교착상태 탐지
- 교착상태 탐지 & 복구는 교착상태 방지를 위한 사전 작업을 하지않아 교착상태가 발생할 수 있다.
- 단, 주기적으로 시스템이 교착상태가 발생했는지 확인을 한다.
- 교착상태 탐지를 위해 RAG(Resource Allocation Graph)를 사용한다.
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/c1574f74-40fc-4667-9a04-4f0932c04b35)
- 위 단계처럼 엣지가 하나도 남지 않고 지울 수 있다면 시스템에 교차 상태에 빠진 프로세스가 없다는 것이다.
- 만약 일부 엣지가 남았다면 시스템에 교착 상태에 빠진 프로세스가 존재함을 알 수 있다.



