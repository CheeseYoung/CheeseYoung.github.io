---
layout: post
title: "[데이터베이스] 8. 인덱스(Index)"
subtitle: Engineer Information Processing
author: Jo
categories: CS
banner:
  image: https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/8ab52fa9-b61b-4ad5-ab7e-13641a30998d
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"
  subheading_style: "color: gold"
tags: Study

---


# 목차
🕳 키(Key) <br>
📌 인덱스(Index) <br>
🕳 정규화(normalization) <br>
🕳 트랜잭션(Transaction) <br>
🕳 이상현상(Anomaly) <br>
🕳 병행제어(Concurrency Control) <br>
<br>
<hr>


## 인덱스(Index)란?
**추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조** <br>
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/8ab52fa9-b61b-4ad5-ab7e-13641a30998d)
- 만약 우리가 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아 보는것은 오랜 시간이 걸린다.
- 그렇기 때문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가하는데, 데이터베이스의 index는 책의 색인과 같다.
- 데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에
- 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.
- 인덱스를 활용하면, 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상된다.
  - 그 이유는 해당 연산을 수행하려면 조회를 해야만 하기 때문이다.
- 만약 index를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 전체를 탐색하는 Full Scan을 수행해야 한다.
- Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.

## 인덱스의 관리
- DBMS는 index를 **항상 최신의 정렬된 상태로 유지**해야 원하는 값을 빠르게 탐색할 수 있다.
- 그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면
- 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다.
  - INSERT: 새로운 데이터에 대한 인덱스를 추가
  - DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행
  - UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가

## 인덱스의 장단점
# 장점
- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.
<br><br>

# 단점
- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
- 인덱스를 관리하기 위해 추가 작업이 필요하다.
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.
<br>
> 만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다.
> 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다.
> 앞에서 설명한대로, UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준다고 하였다.
> 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면
> SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 될 것이다. 

<br><br>

# 인덱스(index)를 사용하면 좋은 경우
- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼
> 인덱스를 사용하는 것 만큼이나 생성된 인덱스를 관리해주는 것도 중요하다. 그러므로 사용되지 않는 인덱스는 바로 제거를 해주어야 한다. 


## 인덱스의 자료구조
# 1. 해시 테이블(Hash table)
- 해시 테이블은 키(Key)와 해시 값(Hash Value) 쌍으로 이루어진 자료구조이다. 
- O(1)의 시간복잡도를 가지고 있어 상당히 빠른 검색을 할 수 있는 것이 특징이다.
- 해시 테이블의 검색 방식은 키를 해시 함수를 사용하여 해시 값으로 변환한 후, 해당 해시 값에 해당하는 값을 찾아서 검색한다.
- 해시 테이블은 검색 속도가 매우 빠르지만, *데이터의 분포에 따라 충돌이 발생*할 수 있다.
- 따라서 충돌을 해결하기 위한 방법이 필요하다.
- 또한, 해시는 **등호(=) 연산에만 특화**되어 있어 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.
 
# 2. B-Tree
- B-Tree는 데이터베이스에서 가장 널리 사용되는 인덱스 자료구조 중 하나이다.
- O(logN)의 시간 복잡도를 가지고 있다.
- B-Tree는 균형 잡힌 이진 검색 트리로 데이터베이스에서 **검색 속도를 높이기 위해 사용**된다.
- B-Tree의 각 노드 내 데이터들은 *항상 정렬된 상태*인 것이 특징이며,
- 데이터와 데이터 사이의 범위를 이용하여 자식 노드를 가진다. (자식 노드의 개수는 n+1개)
- 또한, 한 노드에서 여러 개의 키를 가질 수 있고, 키에 해당하는 데이터도 함께 갖고 있다.
 
# 3. B+Tree
- B+Tree는 B-Tree의 변형된 구조로 B-Tree와 비슷하지만 몇 가지 차이점을 가지고 있다.
- B+Tree 또한 *균형 잡힌 이진 검색 트리*이다.
- B+Tree는 B-Tree에 비해 더 많은 키를 가질 수 있다.
- B+Tree는 B-Tree와 달리 내부 노드(Internal node)와 단말 노드(Leaf node)로 구분된다.
- B+Tree의 **모든 데이터는 단말 노드에서만 저장되며, 내부 노드에는 검색을 위한 인덱스만 저장**된다.
- 모든 리프 노드가 **연결 리스트로 연결**되어 있으며, 순차적으로 저장되어 있다.
- 이러한 특징으로 인해 범위 검색(Range Search)이나 순차 검색(Sequential Search)에 효율적이다.









