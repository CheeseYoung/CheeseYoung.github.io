---
layout: post
title: "[데이터베이스] 12. 병행제어(Concurrency Control)"
subtitle: Engineer Information Processing
author: Jo
categories: CS
banner:
  image: https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/635f890b-0d10-4600-9e73-3ec905373224
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 3em; font-weight: bold;"
  subheading_style: "color: gold"
tags: Study

---

# 목차
🕳 키(Key) <br>
🕳 인덱스(Index) <br>
🕳 정규화(Normalization) <br>
🕳 트랜잭션(Transaction) <br>
🕳 이상현상(Anomaly) <br>
📌 병행제어(Concurrency Control) <br>
<br>
<hr>


## 병행제어(Concurrency Control)
# DBMS 가 다수의 사용자 사이에서 동시에 작용하는 다중 트랜잭션의 상호간섭 작용에서 DB를 보호하는 것
- 일반적인 어플리케이션은 다수의 사용자의 요청을 처리하고,
- 이러한 요청에는 DB 접근을 필요로 하는 요청도 포함된다.
- 이때 한번에 다수의 DB 접근을 필요로 하는 요청이 들어올 때 트랜잭션 단위로 DB 접근을 하게 되는데
- **DB 접근을 동시적으로 모두 허용해주면 데이터베이스의 일관성과 무결성이 깨질 수 있다.**
- 이를 방지하기 위해 **병행제어(= 동시성 제어)** 를 통해 데이터베이스를 보호할 수 있다.
- 병행 제어는 한번에 들어온 **복수의 트랜잭션을 직렬화**하는 수행을 보장한다.
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/635f890b-0d10-4600-9e73-3ec905373224)
- 이 개념에서 ``동시성``과 대조되는 것이 ``일관성``인데,
- **동시성이 높을수록 데이터베이스의 일관성이 깨지게 되어 둘은 반비례 관계**다.
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/d2d17057-fa04-4de7-a621-79a5b192e2ce)
- 다수의 사용자의 동시 접속을 위해 DBMS는 병행 제어를 할 수 있도록 다양한 기법을 제공한다.

## 병행제어 기법 종류

|동시성 제어 기법|설명|
|--|--|
|로킹 기법|트랜잭션이 데이터에 잠금(Lock) 을 설정하면 다른 트랜잭션은 해당 데이터에 대해 잠금이 해제(UnLock)될 때까지 접근/수정/삭제 불가|
|타임 스탬프 기법|시스템에서 생성하는 고유 식별자인 타임 스탬프를 트랜잭션에 부여함으로써 트랜잭션 간의 접근 순서를 미리 정함|
|적합성 검증(낙관적)|먼저 트랜잭션을 수행하고 종료할 때 적합성을 검증하여 데이터베이스에 최종 반영|


## 1) 로킹 기법(Locking Method)
- 트랜잭션이 사용하는 데이터 자원에 대하여 **상호 배제(Mutual Exclusive) 기능을 제공**하는 기법
- 상호 배제는 트랜잭션이 데이터 항목에 대하여 잠금(Lock)을 설정한 트랜잭션이 해재(UnLock)할 때까지 **데이터를 독점적으로 사용**할 수 있는 것을 의미
# 종류
- 공유 Lock(Shared Lock)
  - 공유 잠금한 트랜잭션이 데이터 항목에 대하여 읽기(Read) 만 가능
  - 다른 트랜잭션도 읽기(Read) 만을 실행 할 수 있는 형태
- 전용 Lock(Exclusive Lock)
  - 전용 잠금한 트랜잭션은 데이터 항목에 대하여 읽기(Read) 와 기록(Write) 모두 가능
  - 다른 트랜잭션은 읽기(Read)와 기록(Write) 모두 할 수 없음
<br><br>
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/27675df8-6ba0-45da-b2af-10d4aef4134c)
# 블로킹(Blocking) 현상
- Lock 간 경합이 발생하여 특정 Transaction 작업을 진행하지 못하고 멈춰선 상태
- 공유 Lock 끼리는 서로 특정 데이터에 대해 동시 접근이 가능하기 때문에 블로킹이 발생하지 않는다.
- 공유 Lock - 전용 Lock 혹은 전용 Lock - 공유 Lock 끼리는 블로킹이 발생한다.
- 이러한 현상은 어플리케이션 성능에 좋지 않은 영향을 끼치기 때문에 블로킹을 최소화해야 한다.
- `블로킹` 해결 방법 👍
  1. 한 트랜잭션의 길이를 너무 길게 설계하는 것은 블로킹의 확률을 증가시키므로 가능한 짧게 설계하기
  2. 설계 시, 같은 데이터를 동시에 갱신하는 트랜잭션을 수행하지 않도록 하기
  3. 트랜잭션 격리성 수준을 불필요하게 상향 조정하지 않기
  4. 쿼리를 너무 오랜시간 동안 잡아두지 않도록 적절한 튜닝을 진행하기
<br><br>
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/dcfe22b8-f1fa-4dc7-b729-9fee32f6d31c)
# 교착 상태(DeadLock)
- 두 트랜잭션이 각각 Lock 을 설정하고 서로의 Lock에 접근하여 값을 얻어오려 할 때
- 이미 각 트랜잭션에 의해 Lock 이 설정되어 있기 때문에 **트랜잭션이 영원히 처리가 되지 않는 상태**
- 두 트랜잭션이 공유락을 사용한다면 교착 상태는 발생하지 않는다.
- 하지만 그 외 경우에는 주의를 해서 설계해야 한다.


## 2) 타임 스탬프(Time Stamp)
# 트랜잭션의 순서대로 시간 스탬프를 지정하여 동시성 제어의 기준으로 사용되는 개념
- 타임 스탬프에는 system 시계 사용법과 논리적인 계수기 사용법이 존재한다.
  - System 시계 사용법 : 트랜잭션이 시스템에 들어올 때의 System Clock 적용
  - 논리적인 계수기 사용법 : 트랜잭션의 시간 스탬프는 그 트랜잭션이 시스템에 들어올 때의 시스템 계수기기의 값과 같은 개념

## 3) 적합성 검증(낙관적 검증 기법)
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/8a601bee-9aea-4629-a0dc-f11e9a70aab7)
- 트랜잭션이 어떠한 검증도 수행하지 않고, **일단 트랜잭션을 수행하고 종료시 검증을 수행**하여 데이터베이스에 반영하는 방법
- 만약 트랜잭션의 길이가 길어 장기적으로 트랜잭션이 진행되었는데 Roll Back 되는 경우 자원 낭비
- 동시 사용 빈도가 낮은 시스템에서 사용

## 4) MVCC(다중버전 동시성 제어 기법)
: MVCC(Multi Version Concurreny Control) 는 동시접근을 허용하는 데이터베이스에서 동시성을 제어하기 위해 사용하는 방법
- 데이터에 접근하는 사용자는 접근하는 시점에 데이터베이스 snapshot 을 읽는다.
- 이 snapshot 데이터에 대한 변경이 완료(commit) 될 때까지의 변경사항은 다른 데이터베이스 사용자가 볼 수 없다.
- 이후에 사용자가 업데이트 하면 이전의 데이터를 덮어 씌우는 것이 아니라 **새로운 버전의 데이터를 UNDO 영역에 생성**한다.
- 대신 이전 버전의 데이터와 비교해서 **변경된 내용을 기록**
- 이렇게 **여러 버전의 데이터를 가지며, 현재 실행하고 있는 스케쥴의 직렬 가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법을 MVCC**라고 한다.
- MVCC 접근 방식은 트랜잭션의 대기 시간이 존재하지 않음으로 빠르게 동작할 수 있다.
- 또한, 데이터를 읽기 시작할 때, 다른 트랜잭션이 그 데이터를 삭제하거나 수정해도 **영향을 받지 않고 조회 가능**하다.


## 병행제어를 하지 않으면 발생할 수 있는 문제점

1. 갱신 손실
   - 트랜잭션이 동일 데이터를 동시에 갱신할 경우 발생
   - 특정 트랜잭션의 갱신 내용이 반영되지 않는 오류
2. 현황파악 오류(Dirty Read)
   - 트랜잭션 과정에서 갱신을 하고 트랜잭션 종료하기 전에
   - 다른 트랜잭션이 참조함으로써 조회 결과의 정확성이 깨지는 오류
3. 모순성
   - 두 트랜잭션이 동시에 실행할 때 DB 가 일관성이 없는 상태로 남는 오류
4. 연쇄 복귀
   - 복수의 트랜잭션이 동일한 데이터 공유시 특정 트랜잭션이 처리를 취소할 경우
   - 다른 트랜잭션은 해당 취소를 적용하지 못하는 오류






