---
layout: post
title: <네트워크> 15. 블로킹 vs 논블로킹(Blocking vs Non-blocking)
subtitle: Engineer Information Processing
author: Jo
categories: CS
banner:
  image: https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/6045637f-ac7c-4612-9ba2-f02acdbbe8d6
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"
  subheading_style: "color: gold"
tags: Study

---

# 목차
🕳 웹 통신의 큰 흐름 <br>
🕳 검색창에 Youtube을 치면 일어나는 과정 <br>
🕳 동기 vs 비동기(Synchronous vs Asynchronous) <br>
📌 블로킹 vs 논블로킹(Blocking vs Non-blocking) <br>
🕳 쿠키와 세션 차이(Cookie & Session) <br>
<br>
<hr>




## 동기와 비동기
- 동기/비동기와 블로킹/논블로킹이 헷갈릴 수 있어서 다시 정리해보면,
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/2e013eb7-718b-45ed-9606-cc0a748c8f7c)
- 동기는 데이터의 요청과 결과가 한 자리에서 동시에 일어나며
- 현재 작업의 응답이 끝남과 동시에 다음 작업이 요청된다.
- 비동기는 두 주체가 서로의 시작이나 종료시간에 관계없이 별도의 사작, 종료시간을 가지고 있으며
- 동기방식보다 복잡하지만 자원을 효율적으로 사용할 수 있다는 장점이 있다.
- 둘의 차이점은 **호출되는 함수의 작업 완료 여부를 누가 신경 쓰는지**에 대한 관점으로 볼 수 있다.
  - 동기 vs 비동기 : **처리해야 할 작업들을 어떠한 '흐름'으로 처리 할 것인가**에 대한 관점
  - 블로킹 vs 논블로킹 : **처리되어야 하는 (하나의) 작업이, 전체적인 작업 '흐름'을 막느냐 안막느냐**에 대한 관점

## 블로킹과 논블로킹
- 블로킹, 논블로킹은 주로 멀티 스레딩, I/O 등에서 사용되는 개념으로 함수의 리턴 시점과 제어권에 따라 차이가 난다.
- 블로킹과 논 블로킹의 차이는 **제어권이 어디에 있는지**에 대한 관점으로 볼 수 있다.
  - 제어권 : 자신(함수)의 코드를 실행할 권리 같은 것
  - 제어권을 가진 함수는 자신의 코드를 끝까지 실행한 후에 자신을 호출한 함수에게 제어권을 돌려준다.
- # 블로킹(Blocking)
  - 호출된 함수로 제어권이 넘어가고, 호출된 함수의 작업이 끝난 후
    결과값이 호출한 함수에게 리턴됨과 동시에 제어권도 다시 호출한 함수에게 넘어오는 것
- # 논블로킹(Non-Blocking)
  - 호출할 때 제어권을 넘겨주기는 하지만, 바로 돌려받는다.
  - 제어권을 바로 돌려받아서 가지고 있기 때문에 계속해서 다른 작업을 할 수 있다.

## 동기비동기 X 블로킹논블로킹
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/6045637f-ac7c-4612-9ba2-f02acdbbe8d6)
예시) 업무가 3가지 있음 (세탁기 돌리기, 로봇청소기 돌리기, 식기세척기 돌리기)
1. # 동기(Synchronous) / 블로킹(Blocking)
- 동기방식이기 때문에 호출되는 작업의 완료 여부를 호출하는 함수에서 확인해야한다.
- 블로킹으로 인해 세탁기를 돌렸을 때 제어권은 세탁기로 넘어간다.
- 세탁기가 동작을 마쳤을 때 세탁기가 돌아간 결과(호출된 함수의 결과)와 제어권이 청소하는 사람에게 넘어온다.

2. # 동기(Synchronous) / 논블로킹(Non-Blocking)
- 논블로킹이기 때문에 호출되는 함수는 제어권을 바로 호출하는 함수에게 다시 넘겨준다.
- 동기 방식이기 때문에 호출하는 함수 쪽에서 작업 완료 여부를 신경써야한다.
- 때문에 호출된 함수가 끝났는지 확인하는 요청이 필요하다.
<br>
- 예시로 보면 청소하는 사람은 세탁기를 작동한다.
- 제어권은 바로 청소하는 사람한테 다시 넘어오기 때문에 청소하는 사람은 '다른 업무(로봇 청소기로 바닥 청소하기)'를 할 수 있다.
- 하지만 동기방식이기 때문에 세탁기가 끝났는지 수시로 확인하고, 끝났을 경우 '결괏값을 받아와야 하는 일'이 남아있다.

3. # 비동기(Asynchronous) / 논블로킹(Non-Blocking)
- 가장 일반적으로 이야기되는 비동기 처리 방식
- 비동기 방식이기 때문에 함수를 호출한 곳에서 결과를 처리하지 않고 다른 곳에서 결과를 처리한다.**(Callback)**
- 논블로킹으로 인해 함수가 호출되고 제어권은 바로 호출한 함수로 다시 넘어오게 되어 다른 작업을 이어서 진행할 수 있게 된다.
<br>
- 예시로 보면, 청소하는 사람은 세탁기를 작동해놓고, 결과를 신경쓰지 않은 상태로 바로 다음 업무인 로봇 청소기를 가동한다.
- 각 작동의 결과는 다른 청소하는 사람(**=Callback 함수**)이 완료된 소리를 듣고 처리한다.

4. # 비동기(Asynchronous) / 블로킹(Blocking)
- 비동기 방식이기 때문에 호출하는 함수는 작업 완료 여부를 신경쓰지 않지만
- 블로킹으로 인해 함수가 호출 순간 호출되는 함수에게 제어권이 넘어가고,
- 호출하는 함수는 제어권을 다시 받을 때까지(호출된 함수가 끝날 때까지) 다른 작업을 할 수 없다.
<br>
- 예를 들면 청소하는 사람이 세탁기를 동작시켰을 때, 청소하는 사람은 세탁기의 결과를 신경쓰지 않아도 되지만
- 세탁기의 문제로 세탁기의 세탁 작업이 끝날 때까지 다른 일을 할 수 없다.

## 결론
- 비동기+논블로킹 방식이 가지는 장점이 다른 3가지 경우와 비교하면 독보적이다.
- 흔히 '비동기로 처리했다'는 건 이는 수행하고자 하는 작업이 논블로킹임을 내포하는 말이다.
- 하지만 순차적으로 작업이 처리되어야 한다면 '등기' 혹은 '블로킹' 방식을 사용해야한다.










