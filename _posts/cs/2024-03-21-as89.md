---
layout: post
title: "[데이터베이스] 17. 장애와 회복기법"
subtitle: Engineer Information Processing
author: Jo
categories: CS
banner:
  image: https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/aeac5cfa-eba8-4151-9407-183825690fdd
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 3em; font-weight: bold;"
  subheading_style: "color: gold"
tags: Study

---

# 목차
🕳 DBMS / RDBMS / SQL / NoSQL <br>
🕳 레디스(Redis) <br>
🕳 DB Lock <br>
🕳 클러스터링 vs 리플리케이션(Clustering vs Replication) <br>
📌 장애와 회복기법 <br>
🕳 SQL의 종류 (DDL, DML, DCL, TCL) <br>
<br>
<hr>



## 장애
# 트랜잭션을 더이상 수행할 수 없는 시스템 중단 상태
- 데이터베이스에 장애가 발생해도 DBMS의 회복 기능을 통해 데이터베이스는 정확하고 일관된 상태로 유지할 수 있다
- 장애가 발생하는 원인은 정전, 사용자의 실수, 하드웨어 고장, 소프트웨어 오류, 미디어 장치 고장, 트랜잭션 논리적 오류 등 다양하다.
### 장애의 유형
  - 실행 장애 : 데이터베이스 연산 실패
  - 트랜잭션 장애 : 프로그램 실행 중지
  - 시스템 장애 : 하드웨어 결함
  - 미디어 장애 : 디스크 장치 결함


## 데이터베이스 저장 연산
- 데이터베이스는 비휘발성 저장 장치인 디스크에 저장되어 있다. 
- 응용 프로그램에서 트랜잭션 수행을 지시하면 디스크에서 메인 메모리로 데이터를 보내고 데이터를 다시 디스크로 보내는 작업이 필요하다. 
- 디스크와 메인 메모리 간의 데이터 이동은 블록(block) 단위로 이동하며
- 디스크에 있는 블록을 디스크 블록, 메인 메모리에 있는 블록을 버퍼 블록이라 한다.

- 디스크와 메모리 간의 데이터 이동은 다음 두 연산으로 수행된다.
  - input(X) : 디스크 블록에 저장되어 있는 데이터 X를 메인 메모리 버퍼 블록으로 이동시키는 연산
  - output(X) : 메인 메모리 버퍼 블록에 있는 데이터 X를 디스크 블록으로 이동시키는 연산

- 메인 메모리의 버퍼 블록과 프로그램 변수 간의 데이터 이동은 다음 두 연산으로 수행된다.
  - read(X) : 메인 메모리 버퍼 블록에 저장되어 있는 데이터 X를 프로그램의 변수로 읽어오는 연산
  - write(X) : 프로그램 변수 값을 메인 메모리 버퍼 블록에 있는 데이터 X에 기록하는 연산

- 응용 프로그램에서 트랜잭션 수행을 지시하면 read(X) 연산으로 처리할 데이터를 가져온다. 
- 이때 디스크에 저장된 데이터를 메인 메모리 버퍼 블록으로 가져와야하므로 내부적으로 input(X) 연산이 실행된다.
- read(X) 연산이 실행되어 데이터가 프로그램 변수에 저장되면 트랜잭션의 모든 연산은 프로그램 변수를 대상으로 처리된다.
- 그 후 write(X) 연산이 실행 된 후 output(X) 연산이 실행되어 결과 값이 디스크에 있는 데이터베이스로 전달된다.
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/aeac5cfa-eba8-4151-9407-183825690fdd)

> input과 output이 메인메모리 기준이다. read하려면 input, write하려면 output

트랜잭션에 데이터 이동 연산을 추가해 표현하면 아래와 같이 표현된다.

![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/5c8c0e19-de3d-4e35-820f-5404a0f2e7c8)



## 회복
# 장애로 인해 제대로 실행되지 못한 DB를 이전 상태로 복구하는 작업
- 회복 작업을 위해서는 덤프와 로그가 있어야만 가능하다.
- 장애 발생 시, 가장 최근의 복사본(덤프)을 가져온 후 로그를 보며 복구한다.
- **복사본에는 반영되지 않았지만, 로그상으로 완료된 트랜잭션은 재실행**해서 DB에 반영한다.(Redo)
- 반면 **복사본에 장애 발생 후 진행중이던 트랜잭션이 있다면, 반대로 로그를 보며 취소** 작업을 실시한다. (Undo)
  
### 관련 키워드
  - 덤프(Dump) : 주기적으로 데이터베이스 전체를 다른 저장 장치에 복제하는 것
  - 로그(Log) : 데이터베이스가 변경될 때마다 예전 값과 변경 값을 기록해두는 것
  - 재실행(Redo) : 장애 발생 전, 이미 완료된 트랜잭션을 재실행
  - 취소(Undo) : 장애 발생 후, 진행중이던 트랜잭션을 취소하고 이전 상태로 복구

### 로그 레코드
- 로그는 데이터의 변경 기록만을 별도의 파일에다 저장하는 방법이다.
- 트랜잭션이 수행되면서 로그 파일에 로그 레코드가 기록된다.
- 로그 레코드는 아래의 네 종류로 구분된다.
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/fbb807e6-befe-4bd2-9869-b5fc904e7737)
- 트랜잭션 수행 도중 아래와 같이 로그파일에 로그레코드가 기록된다.
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/d682da2b-02a3-4aaf-aab4-c25becc979af)


### 회복 작업에서의 트랜잭션 (원자성과 영속성)
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/e0151fee-a59c-488f-af8f-39aa2605c311)
- 장애 발생 시점을 기준으로 트랜잭션 완료 여부에 따라 Redo와 Undo로 나누어진다.
- **Redo를 하는 이유는 트랜잭션의 영속성을 만족하기 위해서**다.
- 트랜잭션은 일단 완료되면 그 결과를 영구 기억장치에 저장하고 보존해야한다.
- 이를 위해 다시 Redo 작업을 실시해서 저장한다.
- 반면 **Undo를 하는 이유는 트랜잭션의 원자성을 만족하기 위해서**다.
- 트랜잭션은 전부 실행되거나, 아예 실행되지 않아야한다.
- 장애로 인해 중간 결과만 남은 경우, 다시 실행 이전으로 복구해야한다.


## 데이터베이스 회복 기법
- 데이터베이스 회복 기법은 로그 회복 기법, 검사 시점 회복 기법, 미디어 회복 기법 등이 있다.
- 그 중 ``로그 회복 기법``을 일반적으로 사용한다.
- 회복 연산인 redo와 undo는 회복 기법에서 주요 연산으로 사용된다.

### 로그 회복 기법 종류
로그 회복 기법은 트랜잭션의 데이터 변경 연산 결과를 **언제 데이터베이스에 반영하는지에 따라 즉시 갱신 기법과 지연 갱신 기법**으로 나뉜다.
#### 즉시 갱신 회복 기법
- 트랜잭션 수행 중 데이터 변경 연산 결과를 **데이터베이스에 즉시 반영**한다.
- 트랜잭션에서 데이터 변경 연산이 실행되면 로그 파일에 로그 레코드를 먼저 기록한 후 데이터베이스에 변경 연산 결과를 반영한다.
- 즉시 갱신 회복 기법은 장애가 발생하면 아래의 기준에 따라 트랜잭션에 undo 연산 또는 redo 연산을 실행한다.
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/3643598d-6e61-4503-923f-621424793efd)
- undo 연산을 실행할 트랜잭션이 여러 개인 경우 로그에 기록된 순서의 반대로 undo 연산이 실행되며
- redo 연산을 실행할 트랜잭션이 여러 개인 경우 로그 기록 순서대로 redo 연산이 실행된다.

 > 덤프와 장애 사이에서 완료된 트랜잭션은 redo, 실행 중에 장애가 발생한 트랜잭션은 undo

#### 자연 갱신 회복 기법
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/dfd296c7-5026-42b8-89a0-2b5810fb0fbb)
- 트랜잭션이 수행 중 데이터 변경 연산 결과를 **로그 파일에만 기록해두었다가 commit 이후에만 데이터베이스 반영**한다.
- 따라서 장애 발생 시
  - 아직 완료가 되지 않은 트랜잭션에 undo 연산을 할 필요없이
  - 로그에 기록된 내용을 버리기만 하면 되므로 redo 연산만 사용
- 또한 undo 연산을 하지 않아 *로그 레코드에 이전 값을 기록할 필요가 없*으므로 변경 연산에 대한 로그 레코드는 <Ti,X,newValue> 형식으로 기록된다.
- 지연 갱신 회복 기법은 장애가 발생하면 아래의 기준에 따라 트랜잭션에 redo 연산을 수행한다.
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/9bce4152-4d62-4618-8b81-9fe5f47a0e17)

#### 검사 시점 회복 기법
- 로그 파일 전체를 보고 redo 연산과 undo 연산을 수행하면 회복 시간이 너무 오래 걸린다.
- 따라서 회복에 사용될 로그 기록의 범위를 정할 필요가 있다.
  검사 시점 회복 기법은 로그 회복 기법을 이용하되
  일정 시간 간격으로 검사 시점(checkpoint)를 만들고
  검사 시점 이전의 로그는 회복에 이용되지 않음으로써 회복 시간을 단축시킨다.

#### 미디어 회복 기법
- 데이터베이스가 저장되어 있는 비휘발성 메모리에 장애가 발생할 경우 미디어 회복 기법을 사용한다.
- 미디어 회복 기법은 데이터베이스의 복사본인 덤프 파일을 사용해 데이터베이스를 복구한 후
  필요에 따라 로그 파일을 토대로 redo 연산을 실행한다.

















