---
layout: post
title: <운영체제> 16. 페이징과 세그먼테이션(Paging & Segmentation)
subtitle: Engineer Information Processing
author: Jo
categories: CS
banner:
  image: https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/de46f272-b254-4152-abcb-6cebeeb6ffde
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"
  subheading_style: "color: gold"
tags: Study

---

# 목차
📌 페이징과 세그먼테이션(Paging & Segmentation) <br>
🕳 단편화(Fragmentation) <br>
🕳 가상 메모리 <br>
🕳 메모리 관리 장치(Memory Management Unit) <br>
🕳 페이지 교체 알고리즘 <br>
🕳 캐시 <br>
🕳 IPC(Inter Process Communication) <br>
🕳 파일 시스템(File System) <br>
<br>
<hr>

## 페이징과 세그먼테이션
# 페이지 단위의 논리-물리 주소 관리 기법
- 가상 메모리를 관리하는 기법
- 가상 메모리는 메모리에 로드된, 즉 실행중인 프로세스가 가상의 공간을 참조하여 마치 커다란 물리 메모리를 갖고 있는 것처럼 사용할 수 있도록 하는 것이다.
- 간단하게 말해 **실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식**이다.
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/7388ab67-0cbd-4e18-a081-9692cf6a452c)
**가상메모리**는 각 프로세스당 메인 메모리와 동일한 크기로 하나씩 할당된다. <br>
그 공간은 **보조기억장치 공간을 이용**한다. 프로세스의 일부만 메모리에 로드하고 나머지는 보조기억장치에 두는 형태다. <br>
이렇게 할당되면 **메모리 관리 장치(MMU)** 에 의해 물리 주소로 변환되어 사용자가 메모리 매핑이 어떻게 되는지 의시할 필요없이 알아서 가상 메모리를 활용하여 작업한다.


## 페이징(Paging)
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/de46f272-b254-4152-abcb-6cebeeb6ffde)
- 프로세스의 주소 공간을 고정된 사이즈의 페이지 단위로 나누어 물리적 메모리에 불연속적으로 할당하는 방식
- **메모리는 Frame**이라는 고정크기로 분할되고, **프로세스는 Page**라는 고정크기로 분할됨
- 페이지와 프레임은 크기가 같음
- 페이지와 프레임을 대응시키는 page mapping 과정이 필요하여 paging table을 생성해야 함
- 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제 해결
- 페이지 테이블에는 각 페이지 번호와 해당 페이지가 할당된 프레임의 시작 물리 주소를 저장
**하지만 프로세스의 크기가 페이지 크기의 배수가 아닐 경우 마지막 페이지에 내부 단편화가 발생하고 페이지의 크기가 클수록 내부 단편화가 커진다.** <br>
  => 페이지 단위를 작게 하면 내부 단편화 문제도 해결할 수 있겠지만 page mapping 과정이 많아지므로 효율이 떨어짐
<br><br>
# 페이징 예시
- 50byte 크기의 프로세스가 있다고 가정하고, 페이징의 크기는 10byte로 나눠보자.
- 프로세스 P1은 5개의 페이지로 나눌 수 있다. 이를 메인 메뢰 5곳에 나눠서 할당했다.
- CPU는 논리주소로 프로그램이 설정한대로 연속적인 주소값으로 명령을 내리고, 이는 메모리로 가기 전에 각 페이지의 실제메모리 주소가 저장되어있는 테이블에서 **물리 주소로 변경**되어야 한다.
- 프로세스를 나눈 조각을 Page라 하고, 메모리를 나눈 조각을 Frame이라 한다.
- 프로세스는 페이지의 집합이고, 메모리는 프레임의 집합이다.
- 프로세스를 정상적으로 사용하기 위해 MMU의 재배치 레지스터를 여러개 사용해서 위의 그림과 같이 **각 페이지의 실제 주소로 변경**해준다.
- 이러한 여러개의 재배치 레지스터를 **페이지 테이블**이라 한다.
<br><br>
# 장점
- 외부 단편화가 없다.
<br><br>
# 단점
- 페이지가 클수록 **내부 단편화** 문제의 비중이 늘어나게 된다.


## 세그먼테이션(Segmentation)
# 사용자/프로그래머 관점의 메모리 관리 기법
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/b3f57132-3f8b-46be-9d32-dccb34333f83)
- 프로세스를 서로 크기가 다른 **논리적인 블록 단위인 세그먼트(Segment)로 분할**하여 메모리에 할당
- 논리적 단위로 나뉘기 때문에 미리 분할하는 것이 아니고 **메모리 사용할 시점에 할당**된다.
- 각 세그먼트는 연속적인 공간에 저장
- 세그먼트들의 크기가 서로 다르기 때문에 프로세스가 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법
- 페이징과 마찬가지로 mapping을 위한 segment table 필요
**하지만 프로세스가 필요한 메모리 공간만큼 메모리를 할당해주기 때문에 내부 단편화 문제는 발생하지 않지만, 중간에 메모리를 해제하면 생기는 외부 단편화 문제가 발생한다.** <br>
<br><br>
- 프로세스를 Code + Data + Stack 영역으로 나누는 것 역시 세그멘테이션의 모습이다. 각 내부에서 더 작은 세그먼트로 나눌 수도 있다.
- 세그먼트를 메모리에 할당할 때는 페이지를 할당하는 것과 동일하다.
- 세그먼테이션을 위한 테이블은 **세그먼트 테이블**이라고 한다.
- 세그먼트 테이블은 세그먼트 번호(s)와 시작주소(base), 세그먼트 크기(limit)를 엔트리로 가진다.
- 세그먼트의 크기는 일정하지 않기 때문에, 테이블에 limit 정보가 주어지낟.
- 그리고 CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 **강제로 종료**시킨다.
<br><br>
# 장점
- 내부 단편화가 없다.
- 메모리 사용 효율 개선
<br><br>
# 단점
- 외부 단편화 문제가 발생할 수 있다.


## 세그먼테이션 vs 페이징
세그먼테이션은 페이징과 유사하고 보호와 공유 측면에서는 더 나은 성능을 보여주지만, **현재 대부분은 페이징 기법을 사용한다.** <br>

- 세그먼테이션은 보호와 공유에서 효율적이고, 페이징은 외부 단편화 문제를 해결할 수 있다.
- 그러므로 이 두 가지를 합쳐서 사용하는 방법이 나왔다.
- 두 장점을 합치기 위해서는 **세그먼트를 페이징 기법으로 나누는 것**이다.(**Paged Segment**)

- 이 방법 역시 단점이 존재한다. 세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 두 번 해야 한다.
- 즉, CPU에서 세그먼트 테이블에서 주소 변환을 하고, 그 다음 페이지테이블에서 또 주소 변환을 해야 한다.






















