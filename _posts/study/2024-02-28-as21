---
layout: post
title: 개발 상식 공부하기 21. 트리(Tree)
subtitle: Engineer Information Processing
author: Jo
categories: STUDY
banner:
  video: "./assets/images/banners/typing.gif"
  loop: true
  volume: 0.8
  start_at: 8.5
  image: "assets/images/banners/typing.gif"
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"
  subheading_style: "color: gold"
tags: Study

---

# 목차
📌 트리(Tree) <br>
🕳 힙(Heap) <br>
🕳 B Tree와 B+ Tree <br>
🕳 해시(Hash)<br>
🕳 List, Map, Set <br>

<br>
<hr>





## Tree(트리)
![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/d7289d18-b901-49f9-8c0e-f7cd739a5b30)
- 트리는 연결리스트를 기반으로 한 새로운 데이터 구조
- 연결리스트에서 노드의 연결이 1차원이었다면, 트리에서 노드의 연결은 2차원
- 트리는 최상위 노드(Root)가 있고, 그 아래 하위노드, 그 아래 또 다른 하위노드가 있는 부모(parent)와 자식(child) 형태
- 트리 관련 용어
  - 노드(node) : 트리의 구성요소 (A,B,C,D,E,F,G,H,I,J)
  - 루트 노드(root node) : 트리 구조에서 최상위에 존재하는 노드 (A)
  - 단말 노드(terminal/leaf node) : 아래로 또다른 노드가 연결되어있지 않은 노드(F,G,H,I,J)
  - 비단말 노드(nonterminal/internal node) : 단말 노드를 제외한 모든 노드(A,B,C,D,E)
  - 간선(edge) : 노드와 노드를 연결하는 연결선
  - 형제(sibling) : 같은 부모를 가지는 노드(B-D, D-E, F-G, H-I)
  - 깊이(depth) : 루트 노드에서 어떤 노드에 도달하기 위해 거쳐야하는 간선의 수(F의 depth는 2, H의 depth는 3)
  - 레벨(level) : 트리의 특정 깊이를 가지는 노드의 집합(level 1 = B,C)
  - 차수(degree) : 자식 노드의 개수 (C의 degree = 2, F의 degree = 0)
- 종류
  - # 이진트리(Binary Tree)
    - 조건
      - 루트 노드를 중심으로 두 개의 서브 트리로 나뉘어진다.
      - 나뉘어진 두 서브 트리도 모두 이진 트리여야 한다.(서브트리는 공집합일 수 있다.)
    - 이진트리
      ![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/1de683a7-8546-4583-a184-77099b43372a)
    - 공집합 노드로 채워진 이진트리
      ![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/a3b1eef0-ea95-4c81-8a72-d5b8286a72fd)
      > 노드가 위치할 수 있는 곳에 노드가 존재하지 않는다면 공집합 노드가 존재하는 것으로 간주한다.
  - # 완전 이진 트리(Complete Binary Tree)
    ![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/e2f64544-438f-4600-a967-82db1a4e4179)
    - 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져있다.
    - 노드는 왼쪽 먼저 채워져야한다.
    - 완전 이진 트리는 배열을 사용해 효율적으로 표현 가능하다.
  - # 전 이진 트리(Full Binary Tree)
    ![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/42579ac2-6ddd-4f65-9e7a-4a1cb0391e10)
    - 전 이진 트리는 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리
  - # 포화 이진 트리(Perfect Binary Tree)
    ![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/2f264bd5-d6fe-4299-ac51-76ae93f0d3bc)
    - 포화 이진 트리는 모든 레벨이 노드로 꽉 차 있는 트리
    - 전 이진 트리와 같이 모든 노드가 0개 혹은 2개의 자식 노드를 가져야한다.
    - 모든 말단 노드가 동일한 깊이 또는 레벨을 갖는다.
    - 트리의 노드 개수가 정확히 2^h-1개여야 한다. (h=트리의 높이 / 사진에선 2^3-1=7개)
  - # 이진 탐색 트리(Binary Search Tree)
    ![image](https://github.com/CheeseYoung/Cheeseyoung.github.io/assets/132384527/d7daa244-3372-48ed-9b09-9db04f82495a)
    - 이진 탐색 트리의 노드에 저장된 키(key)는 유일하다.
    - 부모의 키가 왼쪽 자식 노드의 키보다 크다.
    - 부모의 키가 오른쪽 자식 노드의 키보다 작다.
    - 왼쪽과 오른쪽 서브트리도 이진 탐색 트리여야 한다.
    - 이진 탐색 트리의 탐색 과정(빠름)
      - 루트 노드의 키와 찾고자 하는 값을 비교
      - 찾고자하는 값 = 루트 노드 ? 탐색 종료
      - 찾고자하는 값 < 루트 노드 ? 왼쪽 서브트리로 탐색 진행
      - 찾고자하는 값 > 루트 노드 ? 오른쪽 서브트리로 탐색 진행
- 용도
  - 파일 시스템 : 운영체제(Windows, Linux 등)의 디렉터리 구조는 트리로 이루어져 있다.
  - 대진표, 조직도 등

















